# 1. Алгоритм проверки наличия дубликатов в массиве.

def has_duplicates(arr):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j]:
                return True
    return False
'''
Алгоритм имеет сложность O(n^2).
Внешний цикл проходит по всем элементам массива.
Внутренний цикл проходит по каждому i элементу от i+1 и до конца массива.
Лучший вариант O(1), если дубликаты будут находиться сразу.
'''

# 2. Алгоритм поиска максимального элемента в неотсортированном массиве.

def find_max(arr):
    max_val = arr[0]
    for val in arr:
        if val > max_val:
            max_val = val
    return max_val
'''
Алгоритм имеет сложность O(n). 
Цикл проходится по всем элементам массива.
Для определения максимального значения в неотсортированном массиве необходимо пройти и 
проверить каждый элемент, поэтому это будет линейная сложность.
'''

# 3. Алгоритм сортировки выбором (Selection Sort).

def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
'''
Алгоритм имеет сложность О(n^2). 
Внешний цикл проходится по всем элементам массива.
Внутренний цикл проходит по каждому i элементу от i+1 и до конца массива.
Алгоритм будет перебирать массив len(arr) количество раз и каждый раз будет перемещать
минимальный элемент массива влево на нужное место по возрастанию (слева направо).
'''

# 4. Алгоритм быстрой сортировки (Quick Sort).

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
'''
Алгоритм быстрой сортировки имеет сложность О(n log n).
При каждом вызове массив делится пополам.
Если элемент pivot будет выбираться как минимальный или максимальный, тогда алгоритм будет иметь сложность O(n^2).
'''

# 5. Алгоритм вычисления n-го числа Фибоначчи (рекурсивно).

def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
'''
Алгоритм имеет сложность экспоненциальную сложность O(2^n).
Каждый вызов алгоритма создает 2 новых вызова: n-1 и n-2.

Честно, я так и не понял вычисление этого алгоритма, даже с чатом ГПТ :D
'''